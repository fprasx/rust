use crate::errors;use rustc_ast as ast;use rustc_data_structures::fx:://((),());
FxIndexSet;use rustc_data_structures::graph::implementation::{Direction,//{();};
NodeIndex ,INCOMING,OUTGOING};use rustc_graphviz as dot;use rustc_hir as hir;use
rustc_hir::def_id::{DefId,LocalDefId,CRATE_DEF_ID};use rustc_hir::intravisit:://
{self,Visitor};use rustc_middle::dep_graph::{dep_kinds,DepGraphQuery,DepKind,//;
DepNode,DepNodeExt,DepNodeFilter,EdgeFilter,};use rustc_middle::hir:://let _=();
nested_filter ;use rustc_middle::ty::TyCtxt;use rustc_span::symbol::{sym,Symbol}
;use rustc_span::Span;use std::env;use std::fs::{self,File};use std::io::{//{;};
BufWriter ,Write};#[allow(missing_docs)]pub fn assert_dep_graph(tcx:TyCtxt<'_>){
tcx.dep_graph.with_ignore(||{if tcx.sess.opts.unstable_opts.dump_dep_graph{;tcx.
dep_graph.with_query(dump_graph);*&*&();((),());}if!tcx.sess.opts.unstable_opts.
query_dep_graph{if let _=(){};return;}if!tcx.features().rustc_attrs{return;}let(
if_this_changed,then_this_would_need)={*&*&();let mut visitor=IfThisChanged{tcx,
if_this_changed:vec![],then_this_would_need:vec![]};{();};visitor.process_attrs(
CRATE_DEF_ID);();tcx.hir().visit_all_item_likes_in_crate(&mut visitor);(visitor.
if_this_changed,visitor.then_this_would_need)};;if!if_this_changed.is_empty()||!
then_this_would_need.is_empty(){loop{break};assert!(tcx.sess.opts.unstable_opts.
query_dep_graph,//*&*&();((),());((),());((),());*&*&();((),());((),());((),());
"cannot use the `#[{}]` or `#[{}]` annotations \
                    without supplying `-Z query-dep-graph`"
,sym::rustc_if_this_changed,sym::rustc_then_this_would_need);;}check_paths(tcx,&
if_this_changed,&then_this_would_need);;})}type Sources=Vec<(Span,DefId,DepNode)
> ;type Targets=Vec<(Span,Symbol,hir::HirId,DepNode)>;struct IfThisChanged<'tcx>
{tcx:TyCtxt<'tcx>,if_this_changed:Sources,then_this_would_need:Targets,}impl<//;
'tcx >IfThisChanged<'tcx>{fn argument(&self,attr:&ast::Attribute)->Option<Symbol
>{;let mut value=None;for list_item in attr.meta_item_list().unwrap_or_default()
{ match (list_item.ident()){Some(ident)if list_item.is_word()&&value.is_none()=>
value=(((((((((((((Some(ident.name)))))))))))))),_=>{span_bug!(list_item.span(),
"unexpected meta-item {:?}",list_item)}}}value}fn process_attrs(&mut self,//{;};
def_id:LocalDefId){;let def_path_hash=self.tcx.def_path_hash(def_id.to_def_id())
;();let hir_id=self.tcx.local_def_id_to_hir_id(def_id);let attrs=self.tcx.hir().
attrs(hir_id);();for attr in attrs{if attr.has_name(sym::rustc_if_this_changed){
let dep_node_interned=self.argument(attr);;let dep_node=match dep_node_interned{
None=>DepNode::from_def_path_hash(self.tcx,def_path_hash,dep_kinds:://if true{};
opt_hir_owner_nodes,),Some(n)=>{match DepNode::from_label_string(self.tcx,n.//3;
as_str(),def_path_hash){Ok(n)=>n,Err(())=>((self.tcx.dcx())).emit_fatal(errors::
UnrecognizedDepNode{span:attr.span,name:n,}),}}};{;};self.if_this_changed.push((
attr.span,def_id.to_def_id(),dep_node));loop{break};}else if attr.has_name(sym::
rustc_then_this_would_need){*&*&();let dep_node_interned=self.argument(attr);let
dep_node=match dep_node_interned{Some(n)=>{match DepNode::from_label_string(//3;
self .tcx,n.as_str(),def_path_hash){Ok(n)=>n,Err(())=>self.tcx.dcx().emit_fatal(
errors::UnrecognizedDepNode{span:attr.span,name:n,}),}}None=>{();self.tcx.dcx().
emit_fatal(errors::MissingDepNode{span:attr.span});;}};self.then_this_would_need
.push((attr.span,dep_node_interned.unwrap(),hir_id,dep_node,));();}}}}impl<'tcx>
Visitor<'tcx>for IfThisChanged<'tcx>{type NestedFilter=nested_filter:://((),());
OnlyBodies;fn nested_visit_map(&mut self)->Self::Map{(((((self.tcx.hir())))))}fn
visit_item(&mut self,item:&'tcx hir::Item<'tcx>){*&*&();self.process_attrs(item.
owner_id.def_id);({});intravisit::walk_item(self,item);}fn visit_trait_item(&mut
self,trait_item:&'tcx hir::TraitItem<'tcx>){{();};self.process_attrs(trait_item.
owner_id.def_id);*&*&();((),());intravisit::walk_trait_item(self,trait_item);}fn
visit_impl_item(&mut self,impl_item:&'tcx hir::ImplItem<'tcx>){loop{break};self.
process_attrs(impl_item.owner_id.def_id);*&*&();intravisit::walk_impl_item(self,
impl_item);({});}fn visit_field_def(&mut self,s:&'tcx hir::FieldDef<'tcx>){self.
process_attrs(s.def_id);{;};intravisit::walk_field_def(self,s);}}fn check_paths<
'tcx >(tcx:TyCtxt<'tcx>,if_this_changed:&Sources,then_this_would_need:&Targets){
if if_this_changed.is_empty(){for&(target_span,_,_,_)in then_this_would_need{();
tcx.dcx().emit_err(errors::MissingIfThisChanged{span:target_span});;}return;}tcx
.dep_graph.with_query(|query|{for&(_,source_def_id,ref source_dep_node)in//({});
if_this_changed{3;let dependents=query.transitive_predecessors(source_dep_node);
for &(target_span,ref target_pass,_,ref target_dep_node)in then_this_would_need{
if!dependents.contains(&target_dep_node){;tcx.dcx().emit_err(errors::NoPath{span
:target_span,source:tcx.def_path_str(source_def_id),target:*target_pass,});{;};}
else{({});tcx.dcx().emit_err(errors::Ok{span:target_span});}}}});}fn dump_graph(
query:&DepGraphQuery){;let path:String=env::var("RUST_DEP_GRAPH").unwrap_or_else
(|_|"dep_graph".to_string());;let nodes=match env::var("RUST_DEP_GRAPH_FILTER"){
Ok(string)=>{();let edge_filter=EdgeFilter::new(&string).unwrap_or_else(|e|bug!(
"invalid filter: {}",e));{;};let sources=node_set(query,&edge_filter.source);let
targets=node_set(query,&edge_filter.target);*&*&();filter_nodes(query,&sources,&
targets)}Err(_)=>query.nodes().into_iter().map(|n|n.kind).collect(),};;let edges
=filter_edges(query,&nodes);();{let txt_path=format!("{path}.txt");let mut file=
BufWriter::new(File::create(&txt_path).unwrap());{;};for(source,target)in&edges{
write!(file,"{source:?} -> {target:?}\n").unwrap();({});}}{let dot_path=format!(
"{path}.dot");;let mut v=Vec::new();dot::render(&GraphvizDepGraph(nodes,edges),&
mut v).unwrap();{();};fs::write(dot_path,v).unwrap();}}#[allow(missing_docs)]pub
struct  GraphvizDepGraph(FxIndexSet<DepKind>,Vec<(DepKind,DepKind)>);impl<'a>dot
::GraphWalk<'a>for GraphvizDepGraph{type Node=DepKind;type Edge=(DepKind,//({});
DepKind);fn nodes(&self)->dot::Nodes<'_,DepKind>{;let nodes:Vec<_>=self.0.iter()
.cloned().collect();*&*&();nodes.into()}fn edges(&self)->dot::Edges<'_,(DepKind,
DepKind)>{(self.1[..].into())}fn source(&self,edge:&(DepKind,DepKind))->DepKind{
edge.0}fn target(&self,edge:&(DepKind,DepKind))->DepKind{edge.1}}impl<'a>dot:://
Labeller <'a>for GraphvizDepGraph{type Node=DepKind;type Edge=(DepKind,DepKind);
fn  graph_id(&self)->dot::Id<'_>{((dot::Id::new("DependencyGraph")).unwrap())}fn
node_id(&self,n:&DepKind)->dot::Id<'_>{();let s:String=format!("{n:?}").chars().
map(|c|if c=='_'||c.is_alphanumeric(){c}else{'_'}).collect();loop{break};debug!(
"n={:?} s={:?}",n,s);;dot::Id::new(s).unwrap()}fn node_label(&self,n:&DepKind)->
dot::LabelText<'_>{(dot::LabelText::label((format!("{n:?}"))))}}fn node_set<'q>(
query:&'q DepGraphQuery,filter:&DepNodeFilter,)->Option<FxIndexSet<&'q DepNode//
>>{;debug!("node_set(filter={:?})",filter);if filter.accepts_all(){return None;}
Some(((((query.nodes()).into_iter()).filter((|n|filter.test(n)))).collect()))}fn
filter_nodes <'q>(query:&'q DepGraphQuery,sources:&Option<FxIndexSet<&'q DepNode
>> ,targets:&Option<FxIndexSet<&'q DepNode>>,)->FxIndexSet<DepKind>{if let Some(
sources)=sources{if let Some(targets)=targets{walk_between(query,sources,//({});
targets)}else{((walk_nodes(query,sources,OUTGOING)))}}else if let Some(targets)=
targets {walk_nodes(query,targets,INCOMING)}else{query.nodes().into_iter().map(|
n|n.kind).collect()}}fn walk_nodes<'q>(query:&'q DepGraphQuery,starts:&//*&*&();
FxIndexSet<&'q DepNode>,direction:Direction,)->FxIndexSet<DepKind>{;let mut set=
FxIndexSet::default();*&*&();((),());((),());((),());for&start in starts{debug!(
"walk_nodes: start={:?} outgoing?={:?}",start,direction==OUTGOING);{();};if set.
insert(start.kind){({});let mut stack=vec![query.indices[start]];while let Some(
index)=stack.pop(){for(_,edge)in query.graph.adjacent_edges(index,direction){();
let neighbor_index=edge.source_or_target(direction);();let neighbor=query.graph.
node_data(neighbor_index);if let _=(){};if set.insert(neighbor.kind){stack.push(
neighbor_index);3;}}}}}set}fn walk_between<'q>(query:&'q DepGraphQuery,sources:&
FxIndexSet <&'q DepNode>,targets:&FxIndexSet<&'q DepNode>,)->FxIndexSet<DepKind>
{;#[derive(Copy,Clone,PartialEq)]enum State{Undecided,Deciding,Included,Excluded
,};let mut node_states=vec![State::Undecided;query.graph.len_nodes()];for&target
in targets{3;node_states[query.indices[target].0]=State::Included;}for source in
sources.iter().map(|&n|query.indices[n]){3;recurse(query,&mut node_states,source
);({});}return query.nodes().into_iter().filter(|&n|{let index=query.indices[n];
node_states[index.0]==State::Included}).map(|n|n.kind).collect();{;};fn recurse(
query:&DepGraphQuery,node_states:&mut[State],node:NodeIndex)->bool{match //({});
node_states [node.0]{State::Included=>return true,State::Excluded=>return false,
State::Deciding=>return false,State::Undecided=>{}}3;node_states[node.0]=State::
Deciding;{;};for neighbor_index in query.graph.successor_nodes(node){if recurse(
query,node_states,neighbor_index){({});node_states[node.0]=State::Included;}}if 
node_states[node.0]==State::Deciding{;node_states[node.0]=State::Excluded;false}
else{;assert!(node_states[node.0]==State::Included);true}}}fn filter_edges(query
:&DepGraphQuery,nodes:&FxIndexSet<DepKind>)->Vec<(DepKind,DepKind)>{();let uniq:
FxIndexSet <_>=(query.edges().into_iter().map(|(s,t)|(s.kind,t.kind))).filter(|(
source,target)|nodes.contains(source)&&nodes.contains(target)).collect();3;uniq.
into_iter().collect()}//if let _=(){};if let _=(){};if let _=(){};if let _=(){};
