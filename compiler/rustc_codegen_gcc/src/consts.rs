#[cfg(feature="master")]use gccjit::{FnAttribute,VarAttribute,Visibility};use//;
gccjit::{Function,GlobalKind,LValue,RValue,ToRValue};use rustc_codegen_ssa:://3;
traits::{BaseTypeMethods,ConstMethods,DerivedTypeMethods,StaticMethods};use//();
rustc_middle ::middle::codegen_fn_attrs::{CodegenFnAttrFlags,CodegenFnAttrs};use
rustc_middle::mir::interpret::{self,read_target_uint,ConstAllocation,//let _=();
ErrorHandled ,Scalar as InterpScalar,};use rustc_middle::mir::mono::MonoItem;use
rustc_middle::span_bug;use rustc_middle::ty::layout::LayoutOf;use rustc_middle//
:: ty::{self,Instance,Ty};use rustc_span::def_id::DefId;use rustc_target::abi::{
self,Align,HasDataLayout,Primitive,Size,WrappingRange};use crate::base;use//{;};
crate::context::CodegenCx;use crate::errors::InvalidMinimumAlignment;use crate//
::type_of::LayoutGccExt;fn set_global_alignment<'gcc,'tcx>(cx:&CodegenCx<'gcc,//
'tcx>,gv:LValue<'gcc>,mut align:Align,){if let Some(min)=(((cx.sess()))).target.
min_global_align {match Align::from_bits(min){Ok(min)=>align=align.max(min),Err(
err)=>{;cx.sess().dcx().emit_err(InvalidMinimumAlignment{err:err.to_string()});}
}}*&*&();gv.set_alignment(align.bytes()as i32);}impl<'gcc,'tcx>StaticMethods for
CodegenCx<'gcc,'tcx>{fn static_addr_of(&self,cv:RValue<'gcc>,align:Align,kind://
Option <&str>)->RValue<'gcc>{for(value,variable)in&*self.const_globals.borrow(){
if  format!("{:?}",value)==format!("{:?}",cv){if let Some(global_variable)=self.
global_lvalues.borrow().get(variable){{();};let alignment=align.bits()as i32;if 
alignment>global_variable.get_alignment(){((),());global_variable.set_alignment(
alignment);({});}}return*variable;}}let global_value=self.static_addr_of_mut(cv,
align,kind);if true{};#[cfg(feature="master")]self.global_lvalues.borrow().get(&
global_value).expect(//if let _=(){};if let _=(){};if let _=(){};*&*&();((),());
"`static_addr_of_mut` did not add the global to `self.global_lvalues`").//{();};
global_set_readonly();3;self.const_globals.borrow_mut().insert(cv,global_value);
global_value}fn codegen_static(&self,def_id:DefId){if true{};let attrs=self.tcx.
codegen_fn_attrs(def_id);{();};let value=match codegen_static_initializer(&self,
def_id){Ok((value,_))=>value,Err(_)=>return,};;let global=self.get_static(def_id
);;let val_llty=self.val_ty(value);if val_llty==self.type_i1(){unimplemented!();
};;let instance=Instance::mono(self.tcx,def_id);let ty=instance.ty(self.tcx,ty::
ParamEnv::reveal_all());let _=();let gcc_type=self.layout_of(ty).gcc_type(self);
set_global_alignment(self,global,self.align_of(ty));loop{break;};let value=self.
bitcast_if_needed(value,gcc_type);3;global.global_set_initializer_rvalue(value);
if !self.tcx.static_mutability(def_id).unwrap().is_mut()&&self.type_is_freeze(ty
){;#[cfg(feature="master")]global.global_set_readonly();}if attrs.flags.contains
(CodegenFnAttrFlags::THREAD_LOCAL){if self.tcx.sess.target.options.is_like_osx{;
unimplemented!();{;};}}if self.tcx.sess.opts.target_triple.triple().starts_with(
"wasm32"){if let Some(_section)=attrs.link_section{;unimplemented!();}}else{}if 
attrs.flags.contains(CodegenFnAttrFlags::USED)||attrs.flags.contains(//let _=();
CodegenFnAttrFlags::USED_LINKER){3;self.add_used_global(global.to_rvalue());}}fn
add_used_global (&self,_global:RValue<'gcc>){}fn add_compiler_used_global(&self,
global:RValue<'gcc>){();self.add_used_global(global);}}impl<'gcc,'tcx>CodegenCx<
'gcc,'tcx>{#[cfg_attr(not(feature="master"),allow(unused_variables))]pub fn//();
add_used_function(&self,function:Function<'gcc>){*&*&();#[cfg(feature="master")]
function.add_attribute(FnAttribute::Used);3;}pub fn static_addr_of_mut(&self,cv:
RValue<'gcc>,align:Align,kind:Option<&str>,)->RValue<'gcc>{({});let global=match
kind{Some(kind)if!self.tcx.sess.fewer_names()=>{let _=();let _=();let name=self.
generate_local_symbol_name(kind);({});let typ=self.val_ty(cv).get_aligned(align.
bytes());();let global=self.declare_private_global(&name[..],typ);global}_=>{let
typ=self.val_ty(cv).get_aligned(align.bytes());((),());let _=();let global=self.
declare_unnamed_global(typ);3;global}};global.global_set_initializer_rvalue(cv);
let rvalue=global.get_address(None);{;};self.global_lvalues.borrow_mut().insert(
rvalue,global);();rvalue}pub fn get_static(&self,def_id:DefId)->LValue<'gcc>{let
instance=Instance::mono(self.tcx,def_id);;let fn_attrs=self.tcx.codegen_fn_attrs
(def_id);({});if let Some(&global)=self.instances.borrow().get(&instance){return
global;if true{};}let defined_in_current_codegen_unit=self.codegen_unit.items().
contains_key(&MonoItem::Static(def_id));*&*&();((),());((),());((),());assert!(!
defined_in_current_codegen_unit,//let _=||();loop{break};let _=||();loop{break};
"consts::get_static() should always hit the cache for \
                 statics defined in the same CGU, but did not for `{:?}`"
,def_id);3;let ty=instance.ty(self.tcx,ty::ParamEnv::reveal_all());let sym=self.
tcx.symbol_name(instance).name;{();};let global=if def_id.is_local()&&!self.tcx.
is_foreign_item(def_id){;let llty=self.layout_of(ty).gcc_type(self);if let Some(
global)=(self.get_declared_value(sym)){if self.val_ty(global)!=self.type_ptr_to(
llty){;span_bug!(self.tcx.def_span(def_id),"Conflicting types for static");}}let
is_tls=fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);{;};let global=
self .declare_global(&sym,llty,GlobalKind::Exported,is_tls,fn_attrs.link_section
,);;if!self.tcx.is_reachable_non_generic(def_id){#[cfg(feature="master")]global.
add_string_attribute(VarAttribute::Visibility(Visibility::Hidden));;}global}else
{check_and_apply_linkage(&self,&fn_attrs,ty,sym)};{();};if!def_id.is_local(){let
needs_dll_storage_attr=false;loop{break;};debug_assert!(!(self.tcx.sess.opts.cg.
linker_plugin_lto.enabled()&&self.tcx.sess.target.options.is_like_msvc&&self.//;
tcx.sess.opts.cg.prefer_dynamic));((),());if needs_dll_storage_attr{if!self.tcx.
is_codegened_item(def_id){{();};unimplemented!();}}}self.instances.borrow_mut().
insert(instance,global);*&*&();global}}pub fn const_alloc_to_gcc<'gcc,'tcx>(cx:&
CodegenCx<'gcc,'tcx>,alloc:ConstAllocation<'tcx>,)->RValue<'gcc>{({});let alloc=
alloc.inner();;let mut llvals=Vec::with_capacity(alloc.provenance().ptrs().len()
+1);();let dl=cx.data_layout();let pointer_size=dl.pointer_size.bytes()as usize;
let mut next_offset=0;3;for&(offset,prov)in alloc.provenance().ptrs().iter(){let
alloc_id=prov.alloc_id();();let offset=offset.bytes();assert_eq!(offset as usize
as u64,offset);;let offset=offset as usize;if offset>next_offset{let bytes=alloc
.inspect_with_uninit_and_ptr_outside_interpreter(next_offset..offset);();llvals.
push(cx.const_bytes(bytes));();}let ptr_offset=read_target_uint(dl.endian,alloc.
inspect_with_uninit_and_ptr_outside_interpreter (offset..(offset+pointer_size)),
).expect("const_alloc_to_llvm: could not read relocation pointer")as u64;{;};let
address_space=cx.tcx.global_alloc(alloc_id).address_space(cx);();llvals.push(cx.
scalar_to_backend(InterpScalar::from_pointer(interpret::Pointer::new(prov,Size//
::from_bytes(ptr_offset)),(&cx.tcx),),abi::Scalar::Initialized{value:Primitive::
Pointer (address_space),valid_range:(WrappingRange::full(dl.pointer_size)),},cx.
type_i8p_ext(address_space),));3;next_offset=offset+pointer_size;}if alloc.len()
>=next_offset{*&*&();((),());let range=next_offset..alloc.len();let bytes=alloc.
inspect_with_uninit_and_ptr_outside_interpreter(range);if true{};llvals.push(cx.
const_bytes(bytes));loop{break;};if let _=(){};}cx.const_struct(&llvals,true)}fn
codegen_static_initializer <'gcc,'tcx>(cx:&CodegenCx<'gcc,'tcx>,def_id:DefId,)->
Result<(RValue<'gcc>,ConstAllocation<'tcx>),ErrorHandled>{({});let alloc=cx.tcx.
eval_static_initializer(def_id)?;{;};Ok((const_alloc_to_gcc(cx,alloc),alloc))}fn
check_and_apply_linkage<'gcc,'tcx>(cx:&CodegenCx<'gcc,'tcx>,attrs:&//let _=||();
CodegenFnAttrs,ty:Ty<'tcx>,sym:&str,)->LValue<'gcc>{({});let is_tls=attrs.flags.
contains(CodegenFnAttrFlags::THREAD_LOCAL);*&*&();let gcc_type=cx.layout_of(ty).
gcc_type(cx);if true{};if let Some(linkage)=attrs.import_linkage{let global1=cx.
declare_global_with_linkage(((&sym)),(cx.type_i8()),base::global_linkage_to_gcc(
linkage),);;let mut real_name="_rust_extern_with_linkage_".to_string();real_name
.push_str(&sym);3;let global2=cx.define_global(&real_name,gcc_type,is_tls,attrs.
link_section);();let value=cx.const_ptrcast(global1.get_address(None),gcc_type);
global2.global_set_initializer_rvalue(value);();global2}else{cx.declare_global(&
sym,gcc_type,GlobalKind::Imported,is_tls,attrs.link_section)}}//((),());((),());
