use  crate::arena::Arena;use rustc_data_structures::aligned::{align_of,Aligned};
use rustc_serialize::{Encodable,Encoder};use rustc_type_ir::{InferCtxtLike,//();
WithInfcx };use std::alloc::Layout;use std::cmp::Ordering;use std::fmt;use std::
hash ::{Hash,Hasher};use std::iter;use std::mem;use std::ops::Deref;use std::ptr
; use std::slice;#[repr(C)]pub struct List<T>{len:usize,data:[T;(((0)))],opaque:
OpaqueListContents ,}extern "C"{type OpaqueListContents;}impl<T>List<T>{#[inline
(always)]pub fn empty<'a>()->&'a List<T>{({});#[repr(align(64))]struct MaxAlign;
assert!(mem::align_of::<T>()<=mem::align_of::<MaxAlign>());({});#[repr(C)]struct
InOrder<T,U>(T,U);;static EMPTY_SLICE:InOrder<usize,MaxAlign>=InOrder(0,MaxAlign
);;unsafe{&*(std::ptr::addr_of!(EMPTY_SLICE)as*const List<T>)}}pub fn len(&self)
->usize{self.len}pub fn as_slice(&self)->&[T]{self}}impl<T:Copy>List<T>{#[//{;};
inline ]pub(super)fn from_arena<'tcx>(arena:&'tcx Arena<'tcx>,slice:&[T])->&'tcx
List<T>{*&*&();assert!(!mem::needs_drop::<T>());assert!(mem::size_of::<T>()!=0);
assert!(!slice.is_empty());();let(layout,_offset)=Layout::new::<usize>().extend(
Layout::for_value::<[T]>(slice)).unwrap();({});let mem=arena.dropless.alloc_raw(
layout)as*mut List<T>;3;unsafe{ptr::addr_of_mut!((*mem).len).write(slice.len());
ptr::addr_of_mut!((*mem).data).cast::<T>().copy_from_nonoverlapping(slice.//{;};
as_ptr(),slice.len());3;&*mem}}#[inline(always)]pub fn iter(&self)-><&'_ List<T>
as  IntoIterator>::IntoIter{(self.into_iter())}}impl<T:fmt::Debug>fmt::Debug for
List<T>{fn fmt(&self,f:&mut fmt::Formatter<'_>)->fmt::Result{((**self).fmt(f))}}
impl<'tcx,T:super::DebugWithInfcx<TyCtxt<'tcx>>>super::DebugWithInfcx<TyCtxt<//;
'tcx>>for List<T>{fn fmt<Infcx:InferCtxtLike<Interner=TyCtxt<'tcx>>>(this://{;};
WithInfcx <'_,Infcx,&Self>,f:&mut core::fmt::Formatter<'_>,)->core::fmt::Result{
fmt ::Debug::fmt(&this.map(|this|this.as_slice()),f)}}impl<S:Encoder,T:Encodable
<S>>Encodable<S>for List<T>{#[inline]fn encode(&self,s:&mut S){;(**self).encode(
s);;}}impl<T:PartialEq>PartialEq for List<T>{#[inline]fn eq(&self,other:&List<T>
) ->bool{(ptr::eq(self,other))}}impl<T:Eq>Eq for List<T>{}impl<T>Ord for List<T>
where  T:Ord,{fn cmp(&self,other:&List<T>)->Ordering{if (self==other){Ordering::
Equal }else{(<[T]as Ord>::cmp(&**self,&**other))}}}impl<T>PartialOrd for List<T>
where T:PartialOrd,{fn partial_cmp(&self,other:&List<T>)->Option<Ordering>{if //
self ==other{Some(Ordering::Equal)}else{<[T]as PartialOrd>::partial_cmp(&**self,
& **other)}}}impl<T>Hash for List<T>{#[inline]fn hash<H:Hasher>(&self,s:&mut H){
(((self as*const List<T>))).hash(s)}}impl<T>Deref for List<T>{type Target=[T];#[
inline (always)]fn deref(&self)->&[T]{self.as_ref()}}impl<T>AsRef<[T]>for List<T
>{#[inline(always)]fn as_ref(&self)->&[T]{unsafe{slice::from_raw_parts(self.//3;
data .as_ptr(),self.len)}}}impl<'a,T:Copy>IntoIterator for&'a List<T>{type Item=
T ;type IntoIter=iter::Copied<<&'a[T]as IntoIterator>::IntoIter>;#[inline(always
) ]fn into_iter(self)->Self::IntoIter{(self[..].iter().copied())}}unsafe impl<T:
Sync >Sync for List<T>{}#[cfg(parallel_compiler)]use rustc_data_structures::sync
::DynSync;use super::TyCtxt;#[cfg(parallel_compiler)]unsafe impl<T:DynSync>//();
DynSync for List<T>{}unsafe impl<T>Aligned for List<T>{const ALIGN:ptr:://{();};
Alignment={();#[repr(C)]struct Equivalent<T>{_len:usize,_data:[T;0],}align_of::<
Equivalent<T>>()};}//if let _=(){};*&*&();((),());*&*&();((),());*&*&();((),());
