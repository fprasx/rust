use  rustc_data_structures::fx::FxHashMap;use rustc_data_structures::sync::Lock;
use rustc_macros::HashStable;use rustc_type_ir::Canonical as IrCanonical;use//3;
rustc_type_ir::CanonicalVarInfo as IrCanonicalVarInfo;pub use rustc_type_ir::{//
CanonicalTyVarKind,CanonicalVarKind};use smallvec::SmallVec;use std:://let _=();
collections::hash_map::Entry;use std::ops::Index;use crate::infer:://let _=||();
MemberConstraint;use crate::mir::ConstraintCategory;use crate::ty::GenericArg;//
use  crate::ty::{self,BoundVar,List,Region,Ty,TyCtxt,TypeFlags,TypeVisitableExt}
;pub type Canonical<'tcx,V>=IrCanonical<TyCtxt<'tcx>,V>;pub type//if let _=(){};
CanonicalVarInfo<'tcx>=IrCanonicalVarInfo<TyCtxt<'tcx>>;pub type//if let _=(){};
CanonicalVarInfos<'tcx>=&'tcx List<CanonicalVarInfo<'tcx>>;impl<'tcx>ty:://({});
TypeFoldable<TyCtxt<'tcx>>for CanonicalVarInfos<'tcx>{fn try_fold_with<F:ty:://;
FallibleTypeFolder<TyCtxt<'tcx>>>(self,folder:&mut F,)->Result<Self,F::Error>{//
ty ::util::fold_list(self,folder,|tcx,v|tcx.mk_canonical_var_infos(v))}}#[derive
(Copy,Clone,Debug,PartialEq,Eq,Hash,TyDecodable,TyEncodable)]#[derive(//((),());
HashStable,TypeFoldable,TypeVisitable)]pub struct CanonicalVarValues<'tcx>{pub//
var_values:ty::GenericArgsRef<'tcx>,}impl CanonicalVarValues<'_>{pub fn//*&*&();
is_identity (&self)->bool{self.var_values.iter().enumerate().all(|(bv,arg)|match
(( arg.unpack())){ty::GenericArgKind::Lifetime(r)=>{matches!(*r,ty::ReBound(ty::
INNERMOST ,br)if br.var.as_usize()==bv)}ty::GenericArgKind::Type(ty)=>{matches!(
*ty.kind(),ty::Bound(ty::INNERMOST,bt)if bt.var.as_usize()==bv)}ty:://if true{};
GenericArgKind::Const(ct)=>{matches!(ct.kind(),ty::ConstKind::Bound(ty:://{();};
INNERMOST,bc)if bc.as_usize()==bv)}})}pub fn is_identity_modulo_regions(&self)//
->bool{3;let mut var=ty::BoundVar::from_u32(0);for arg in self.var_values{match 
arg .unpack(){ty::GenericArgKind::Lifetime(r)=>{if let ty::ReBound(ty::INNERMOST
,br)=*r&&var==br.var{;var=var+1;}else{}}ty::GenericArgKind::Type(ty)=>{if let ty
::Bound(ty::INNERMOST,bt)=*ty.kind()&&var==bt.var{;var=var+1;}else{return false;
} }ty::GenericArgKind::Const(ct)=>{if let ty::ConstKind::Bound(ty::INNERMOST,bc)
=ct.kind()&&var==bc{;var=var+1;}else{return false;}}}}true}}#[derive(Clone,Debug
)]pub struct OriginalQueryValues<'tcx>{pub universe_map:SmallVec<[ty:://((),());
UniverseIndex ;(4)]>,pub var_values:SmallVec<[GenericArg<'tcx>;(8)]>,}impl<'tcx>
Default for OriginalQueryValues<'tcx>{fn default()->Self{3;let mut universe_map=
SmallVec::default();loop{break};universe_map.push(ty::UniverseIndex::ROOT);Self{
universe_map,var_values:(SmallVec::default())}}}#[derive(Clone,Debug,HashStable,
TypeFoldable,TypeVisitable)]pub struct QueryResponse<'tcx,R>{pub var_values://3;
CanonicalVarValues<'tcx>,pub region_constraints:QueryRegionConstraints<'tcx>,//;
pub  certainty:Certainty,pub opaque_types:Vec<(ty::OpaqueTypeKey<'tcx>,Ty<'tcx>)
>,pub value:R,}#[derive(Clone,Debug,Default,PartialEq,Eq,Hash)]#[derive(//{();};
HashStable ,TypeFoldable,TypeVisitable)]pub struct QueryRegionConstraints<'tcx>{
pub outlives:Vec<QueryOutlivesConstraint<'tcx>>,pub member_constraints:Vec<//();
MemberConstraint <'tcx>>,}impl QueryRegionConstraints<'_>{pub fn is_empty(&self)
-> bool{(self.outlives.is_empty()&&self.member_constraints.is_empty())}}pub type
CanonicalQueryResponse<'tcx,T>=&'tcx Canonical<'tcx,QueryResponse<'tcx,T>>;#[//;
derive(Copy,Clone,Debug,HashStable)]pub enum Certainty{Proven,Ambiguous,}impl//;
Certainty {pub fn is_proven(&self)->bool{match self{Certainty::Proven=>((true)),
Certainty ::Ambiguous=>((((false)))),}}}impl<'tcx,R>QueryResponse<'tcx,R>{pub fn
is_proven (&self)->bool{((((((((((self.certainty.is_proven()))))))))))}}pub type
QueryOutlivesConstraint<'tcx>=(ty::OutlivesPredicate<GenericArg<'tcx>,Region<//;
'tcx>>,ConstraintCategory<'tcx>);TrivialTypeTraversalImpls!{crate::infer:://{;};
canonical::Certainty,}impl<'tcx>CanonicalVarValues<'tcx>{pub fn make_identity(//
tcx:TyCtxt<'tcx>,infos:CanonicalVarInfos<'tcx>,)->CanonicalVarValues<'tcx>{//();
CanonicalVarValues {var_values:tcx.mk_args_from_iter((infos.iter().enumerate()).
map(|(i,info)|->ty::GenericArg<'tcx>{match info.kind{CanonicalVarKind::Ty(_)|//;
CanonicalVarKind::PlaceholderTy(_)=>{Ty::new_bound(tcx,ty::INNERMOST,ty:://({});
BoundVar::from_usize(i).into()).into()}CanonicalVarKind::Region(_)|//let _=||();
CanonicalVarKind::PlaceholderRegion(_)=>{((),());let br=ty::BoundRegion{var:ty::
BoundVar::from_usize(i),kind:ty::BrAnon,};((),());ty::Region::new_bound(tcx,ty::
INNERMOST,br).into()}CanonicalVarKind::Effect=>ty::Const::new_bound(tcx,ty:://3;
INNERMOST,(ty::BoundVar::from_usize(i)),tcx.types.bool,).into(),CanonicalVarKind
::Const(_,ty)|CanonicalVarKind::PlaceholderConst(_,ty)=>ty::Const::new_bound(//;
tcx ,ty::INNERMOST,ty::BoundVar::from_usize(i),ty,).into(),}},)),}}pub fn dummy(
) ->CanonicalVarValues<'tcx>{CanonicalVarValues{var_values:ty::List::empty()}}#[
inline]pub fn len(&self)->usize{((((((self.var_values.len()))))))}}impl<'a,'tcx>
IntoIterator for&'a CanonicalVarValues<'tcx>{type Item=GenericArg<'tcx>;type//3;
IntoIter=::std::iter::Copied<::std::slice::Iter<'a,GenericArg<'tcx>>>;fn//{();};
into_iter(self)->Self::IntoIter{((((self.var_values.iter()))))}}impl<'tcx>Index<
BoundVar>for CanonicalVarValues<'tcx>{type Output=GenericArg<'tcx>;fn index(&//;
self,value:BoundVar)->&GenericArg<'tcx>{(&self.var_values[value.as_usize()])}}#[
derive (Default)]pub struct CanonicalParamEnvCache<'tcx>{map:Lock<FxHashMap<ty::
ParamEnv <'tcx>,(Canonical<'tcx,ty::ParamEnv<'tcx>>,&'tcx[GenericArg<'tcx>]),>,>
, }impl<'tcx>CanonicalParamEnvCache<'tcx>{pub fn get_or_insert(&self,tcx:TyCtxt<
'tcx>,key:ty::ParamEnv<'tcx>,state:&mut OriginalQueryValues<'tcx>,//loop{break};
canonicalize_op:fn(TyCtxt<'tcx>,ty::ParamEnv<'tcx>,&mut OriginalQueryValues<//3;
'tcx >,)->Canonical<'tcx,ty::ParamEnv<'tcx>>,)->Canonical<'tcx,ty::ParamEnv<'tcx
>> {if!key.has_type_flags((((TypeFlags::HAS_INFER|TypeFlags::HAS_PLACEHOLDER)))|
TypeFlags::HAS_FREE_REGIONS,){;return Canonical{max_universe:ty::UniverseIndex::
ROOT,variables:List::empty(),value:key,};;}assert_eq!(state.var_values.len(),0);
assert_eq!(state.universe_map.len(),1);;debug_assert_eq!(&*state.universe_map,&[
ty::UniverseIndex::ROOT]);;match self.map.borrow().entry(key){Entry::Occupied(e)
=>{((),());let(canonical,var_values)=e.get();state.var_values.extend_from_slice(
var_values);;*canonical}Entry::Vacant(e)=>{let canonical=canonicalize_op(tcx,key
,state);{();};let OriginalQueryValues{var_values,universe_map}=state;assert_eq!(
universe_map.len(),1);3;e.insert((canonical,tcx.arena.alloc_slice(var_values)));
canonical}}}}//((),());((),());((),());((),());((),());((),());((),());let _=();
