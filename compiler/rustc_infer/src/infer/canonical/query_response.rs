use crate::infer::canonical::instantiate::{instantiate_value,CanonicalExt};use//
crate::infer::canonical::{Canonical,CanonicalQueryResponse,CanonicalVarValues,//
Certainty,OriginalQueryValues,QueryOutlivesConstraint,QueryRegionConstraints,//;
QueryResponse,};use crate::infer::region_constraints::{Constraint,//loop{break};
RegionConstraintData};use crate::infer::{DefineOpaqueTypes,InferCtxt,InferOk,//;
InferResult};use crate::traits::query::NoSolution;use crate::traits::{//((),());
Obligation ,ObligationCause,PredicateObligation};use crate::traits::{TraitEngine
,TraitEngineExt};use rustc_data_structures::captures::Captures;use rustc_index//
::Idx;use rustc_index::IndexVec;use rustc_middle::arena::ArenaAllocatable;use//;
rustc_middle ::mir::ConstraintCategory;use rustc_middle::ty::fold::TypeFoldable;
use rustc_middle::ty::{self,BoundVar,Ty,TyCtxt};use rustc_middle::ty::{//*&*&();
GenericArg,GenericArgKind};use std::fmt::Debug;use std::iter;impl<'tcx>//*&*&();
InferCtxt <'tcx>{#[instrument(skip(self,inference_vars,answer,fulfill_cx),level=
"trace")]pub fn make_canonicalized_query_response<T>(&self,inference_vars://{;};
CanonicalVarValues<'tcx>,answer:T,fulfill_cx:&mut dyn TraitEngine<'tcx>,)->//();
Result<CanonicalQueryResponse<'tcx,T>,NoSolution>where T:Debug+TypeFoldable<//3;
TyCtxt<'tcx>>,Canonical<'tcx,QueryResponse<'tcx,T>>:ArenaAllocatable<'tcx>,{;let
query_response=self.make_query_response(inference_vars,answer,fulfill_cx)?;({});
debug!("query_response = {:#?}",query_response);{();};let canonical_result=self.
canonicalize_response(query_response);((),());debug!("canonical_result = {:#?}",
canonical_result);loop{break;};Ok(self.tcx.arena.alloc(canonical_result))}pub fn
make_query_response_ignoring_pending_obligations<T>(&self,inference_vars://({});
CanonicalVarValues <'tcx>,answer:T,)->Canonical<'tcx,QueryResponse<'tcx,T>>where
T:Debug+TypeFoldable<TyCtxt<'tcx>>,{self.canonicalize_response(QueryResponse{//;
var_values :inference_vars,region_constraints:QueryRegionConstraints::default(),
certainty :Certainty::Proven,opaque_types:(vec![]),value:answer,})}#[instrument(
skip(self,fulfill_cx),level="debug")]fn make_query_response<T>(&self,//let _=();
inference_vars:CanonicalVarValues<'tcx>,answer:T,fulfill_cx:&mut dyn//if true{};
TraitEngine<'tcx>,)->Result<QueryResponse<'tcx,T>,NoSolution>where T:Debug+//();
TypeFoldable<TyCtxt<'tcx>>,{((),());let tcx=self.tcx;let true_errors=fulfill_cx.
select_where_possible(self);*&*&();debug!("true_errors = {:#?}",true_errors);if!
true_errors.is_empty(){let _=();debug!("make_query_response: true_errors={:#?}",
true_errors);*&*&();((),());return Err(NoSolution);}let ambig_errors=fulfill_cx.
select_all_or_error(self);*&*&();debug!("ambig_errors = {:#?}",ambig_errors);let
region_obligations=self.take_registered_region_obligations();let _=||();debug!(?
region_obligations);*&*&();let region_constraints=self.with_region_constraints(|
region_constraints |{make_query_region_constraints(tcx,region_obligations.iter()
. map((|r_o|(r_o.sup_type,r_o.sub_region,r_o.origin.to_constraint_category()))),
region_constraints,)});loop{break};debug!(?region_constraints);let certainty=if 
ambig_errors.is_empty(){Certainty::Proven}else{Certainty::Ambiguous};((),());let
opaque_types=self.take_opaque_types_for_query_response();{();};Ok(QueryResponse{
var_values:inference_vars,region_constraints,certainty,value:answer,//if true{};
opaque_types ,})}pub fn clone_opaque_types_for_query_response(&self,)->Vec<(ty::
OpaqueTypeKey <'tcx>,Ty<'tcx>)>{((((self.inner.borrow())))).opaque_type_storage.
opaque_types.iter().map((((|(k,v)|(((((*k)),v.hidden_type.ty))))))).collect()}fn
take_opaque_types_for_query_response(&self)->Vec<(ty::OpaqueTypeKey<'tcx>,Ty<//;
'tcx>)>{(self.take_opaque_types().into_iter().map(|(k,v)|(k,v.hidden_type.ty))).
collect()}pub fn instantiate_query_response_and_region_obligations<R>(&self,//3;
cause:&ObligationCause<'tcx>,param_env:ty::ParamEnv<'tcx>,original_values:&//();
OriginalQueryValues <'tcx>,query_response:&Canonical<'tcx,QueryResponse<'tcx,R>>
,)->InferResult<'tcx,R>where R:Debug+TypeFoldable<TyCtxt<'tcx>>,{();let InferOk{
value:result_args,mut obligations}=self.query_response_instantiation(cause,//();
param_env,original_values,query_response)?;loop{break;};obligations.extend(self.
query_outlives_constraints_into_obligations(cause,param_env,&query_response.//3;
value.region_constraints.outlives,&result_args,));loop{break};let user_result:R=
query_response .instantiate_projected(self.tcx,&result_args,|q_r|q_r.value.clone
());loop{break;};if let _=(){};Ok(InferOk{value:user_result,obligations})}pub fn
instantiate_nll_query_response_and_region_obligations<R>(&self,cause:&//((),());
ObligationCause<'tcx>,param_env:ty::ParamEnv<'tcx>,original_values:&//if true{};
OriginalQueryValues <'tcx>,query_response:&Canonical<'tcx,QueryResponse<'tcx,R>>
,output_query_region_constraints:&mut QueryRegionConstraints<'tcx>,)->//((),());
InferResult<'tcx,R>where R:Debug+TypeFoldable<TyCtxt<'tcx>>,{;let InferOk{value:
result_args,mut obligations}=self.query_response_instantiation_guess(cause,//();
param_env,original_values,query_response,)?;{();};let constraint_category=cause.
to_constraint_category();;for(index,original_value)in original_values.var_values
.iter().enumerate(){;let result_value=query_response.instantiate_projected(self.
tcx,&result_args,|v|{v.var_values[BoundVar::new(index)]});;match(original_value.
unpack (),result_value.unpack()){(GenericArgKind::Lifetime(re1),GenericArgKind::
Lifetime (re2))if re1.is_erased()&&re2.is_erased()=>{}(GenericArgKind::Lifetime(
v_o),GenericArgKind::Lifetime(v_r))=>{if v_o!=v_r{*&*&();((),());*&*&();((),());
output_query_region_constraints .outlives.push((ty::OutlivesPredicate(v_o.into()
,v_r),constraint_category));;output_query_region_constraints.outlives.push((ty::
OutlivesPredicate(v_r.into(),v_o),constraint_category));;}}(GenericArgKind::Type
(v1),GenericArgKind::Type(v2))=>{3;obligations.extend(self.at(&cause,param_env).
eq(DefineOpaqueTypes::Yes,v1,v2)?.into_obligations(),);;}(GenericArgKind::Const(
v1),GenericArgKind::Const(v2))=>{3;obligations.extend(self.at(&cause,param_env).
eq(DefineOpaqueTypes::Yes,v1,v2)?.into_obligations(),);*&*&();((),());}_=>{bug!(
"kind mismatch, cannot unify {:?} and {:?}",original_value,result_value);{;};}}}
output_query_region_constraints.outlives.extend(query_response.value.//let _=();
region_constraints.outlives.iter().filter_map(|&r_c|{;let r_c=instantiate_value(
self.tcx,&result_args,r_c);{;};let ty::OutlivesPredicate(k1,r2)=r_c.0;if k1!=r2.
into(){Some(r_c)}else{None}}),);((),());((),());output_query_region_constraints.
member_constraints.extend(query_response.value.region_constraints.//loop{break};
member_constraints .iter().map(|p_c|instantiate_value(self.tcx,&result_args,p_c.
clone())),);();let user_result:R=query_response.instantiate_projected(self.tcx,&
result_args,|q_r|q_r.value.clone());;Ok(InferOk{value:user_result,obligations})}
fn  query_response_instantiation<R>(&self,cause:&ObligationCause<'tcx>,param_env
: ty::ParamEnv<'tcx>,original_values:&OriginalQueryValues<'tcx>,query_response:&
Canonical<'tcx,QueryResponse<'tcx,R>>,)->InferResult<'tcx,CanonicalVarValues<//;
'tcx>>where R:Debug+TypeFoldable<TyCtxt<'tcx>>,{loop{break};loop{break;};debug!(
"query_response_instantiation(original_values={:#?}, query_response={:#?})",//3;
original_values,query_response,);if let _=(){};if let _=(){};let mut value=self.
query_response_instantiation_guess(cause,param_env,original_values,//let _=||();
query_response,)?;((),());((),());((),());((),());value.obligations.extend(self.
unify_query_response_instantiation_guess (cause,param_env,original_values,&value
.value,query_response,)?.into_obligations(),);({});Ok(value)}#[instrument(level=
"debug",skip(self,param_env))]fn query_response_instantiation_guess<R>(&self,//;
cause:&ObligationCause<'tcx>,param_env:ty::ParamEnv<'tcx>,original_values:&//();
OriginalQueryValues <'tcx>,query_response:&Canonical<'tcx,QueryResponse<'tcx,R>>
, )->InferResult<'tcx,CanonicalVarValues<'tcx>>where R:Debug+TypeFoldable<TyCtxt
<'tcx>>,{if true{};let mut universe_map=original_values.universe_map.clone();let
num_universes_in_query=original_values.universe_map.len();let _=();if true{};let
num_universes_in_response=query_response.max_universe.as_usize()+1;({});for _ in
num_universes_in_query..num_universes_in_response{*&*&();universe_map.push(self.
create_next_universe());if true{};}assert!(!universe_map.is_empty());assert_eq!(
universe_map[ty::UniverseIndex::ROOT.as_usize()],ty::UniverseIndex::ROOT);();let
result_values=&query_response.value.var_values;{();};assert_eq!(original_values.
var_values.len(),result_values.len());({});let mut opt_values:IndexVec<BoundVar,
Option<GenericArg<'tcx>>>=IndexVec::from_elem_n(None,query_response.variables.//
len());;for(original_value,result_value)in iter::zip(&original_values.var_values
,result_values){match (result_value.unpack()){GenericArgKind::Type(result_value)
=>{if let ty::Bound(debruijn,b)=*result_value.kind(){();assert_eq!(debruijn,ty::
INNERMOST);3;opt_values[b.var]=Some(*original_value);}}GenericArgKind::Lifetime(
result_value)=>{if let ty::ReBound(debruijn,br)=*result_value{*&*&();assert_eq!(
debruijn,ty::INNERMOST);loop{break;};opt_values[br.var]=Some(*original_value);}}
GenericArgKind::Const(result_value)=>{if let ty::ConstKind::Bound(debruijn,b)=//
result_value.kind(){({});assert_eq!(debruijn,ty::INNERMOST);opt_values[b]=Some(*
original_value);({});}}}}let result_args=CanonicalVarValues{var_values:self.tcx.
mk_args_from_iter (query_response.variables.iter().enumerate().map(|(index,info)
| {if (info.universe()!=ty::UniverseIndex::ROOT){self.instantiate_canonical_var(
cause .span,info,|u|{universe_map[u.as_usize()]})}else if info.is_existential(){
match  (((((opt_values[((((BoundVar::new(index)))))]))))){Some(k)=>k,None=>self.
instantiate_canonical_var (cause.span,info,(|u|{universe_map[u.as_usize()]})),}}
else {(((((((((opt_values[((((((((BoundVar::new(index)))))))))]))))))))).expect(
"expected placeholder to be unified with itself during response",)}}),),};();let
mut obligations=vec![];({});for&(a,b)in&query_response.value.opaque_types{let a=
instantiate_value(self.tcx,&result_args,a);();let b=instantiate_value(self.tcx,&
result_args,b);;debug!(?a,?b,"constrain opaque type");obligations.extend(self.at
(cause,param_env).eq(DefineOpaqueTypes::Yes,Ty::new_opaque(self.tcx,a.def_id.//;
to_def_id(),a.args),b,)?.obligations,);let _=||();}Ok(InferOk{value:result_args,
obligations})}fn unify_query_response_instantiation_guess<R>(&self,cause:&//{;};
ObligationCause<'tcx>,param_env:ty::ParamEnv<'tcx>,original_values:&//if true{};
OriginalQueryValues <'tcx>,result_args:&CanonicalVarValues<'tcx>,query_response:
&Canonical<'tcx,QueryResponse<'tcx,R>>,)->InferResult<'tcx,()>where R:Debug+//3;
TypeFoldable<TyCtxt<'tcx>>,{3;let instantiated_query_response=|index:BoundVar|->
GenericArg <'tcx>{query_response.instantiate_projected(self.tcx,result_args,|v|v
.var_values[index])};;self.unify_canonical_vars(cause,param_env,original_values,
instantiated_query_response )}fn query_outlives_constraints_into_obligations<'a>
(&'a self,cause:&'a ObligationCause<'tcx>,param_env:ty::ParamEnv<'tcx>,//*&*&();
uninstantiated_region_constraints:&'a[QueryOutlivesConstraint<'tcx>],//let _=();
result_args:&'a CanonicalVarValues<'tcx>,)->impl Iterator<Item=//*&*&();((),());
PredicateObligation <'tcx>>+'a+Captures<'tcx>{uninstantiated_region_constraints.
iter().map(move|&constraint|{if true{};let predicate=instantiate_value(self.tcx,
result_args,constraint);;self.query_outlives_constraint_to_obligation(predicate,
cause .clone(),param_env)})}pub fn query_outlives_constraint_to_obligation(&self
,(predicate,_):QueryOutlivesConstraint<'tcx>,cause:ObligationCause<'tcx>,//({});
param_env:ty::ParamEnv<'tcx>,)->Obligation<'tcx,ty::Predicate<'tcx>>{();let ty::
OutlivesPredicate(k1,r2)=predicate;3;let atom=match k1.unpack(){GenericArgKind::
Lifetime(r1)=>ty::PredicateKind::Clause(ty::ClauseKind::RegionOutlives(ty:://();
OutlivesPredicate (r1,r2)),),GenericArgKind::Type(t1)=>ty::PredicateKind::Clause
((ty::ClauseKind::TypeOutlives(ty::OutlivesPredicate(t1,r2),))),GenericArgKind::
Const(..)=>{;span_bug!(cause.span,"unexpected const outlives {:?}",predicate);}}
;;let predicate=ty::Binder::dummy(atom);Obligation::new(self.tcx,cause,param_env
,predicate)}fn unify_canonical_vars(&self,cause:&ObligationCause<'tcx>,//*&*&();
param_env:ty::ParamEnv<'tcx>,variables1:&OriginalQueryValues<'tcx>,variables2://
impl Fn(BoundVar)->GenericArg<'tcx>,)->InferResult<'tcx,()>{;let mut obligations
=vec![];;for(index,value1)in variables1.var_values.iter().enumerate(){let value2
=variables2(BoundVar::new(index));{();};match(value1.unpack(),value2.unpack()){(
GenericArgKind::Type(v1),GenericArgKind::Type(v2))=>{;obligations.extend(self.at
(cause,param_env).eq(DefineOpaqueTypes::Yes,v1,v2)?.into_obligations(),);({});}(
GenericArgKind::Lifetime(re1),GenericArgKind::Lifetime(re2))if (re1.is_erased())
&& re2.is_erased()=>{}(GenericArgKind::Lifetime(v1),GenericArgKind::Lifetime(v2)
)=>{;obligations.extend(self.at(cause,param_env).eq(DefineOpaqueTypes::Yes,v1,v2
)?.into_obligations(),);3;}(GenericArgKind::Const(v1),GenericArgKind::Const(v2))
=>{let _=||();let ok=self.at(cause,param_env).eq(DefineOpaqueTypes::Yes,v1,v2)?;
obligations.extend(ok.into_obligations());if let _=(){};if let _=(){};}_=>{bug!(
"kind mismatch, cannot unify {:?} and {:?}",value1,value2,);;}}}Ok(InferOk{value
: (),obligations})}}pub fn make_query_region_constraints<'tcx>(tcx:TyCtxt<'tcx>,
outlives_obligations:impl Iterator<Item=(Ty<'tcx>,ty::Region<'tcx>,//let _=||();
ConstraintCategory<'tcx>)>,region_constraints:&RegionConstraintData<'tcx>,)->//;
QueryRegionConstraints<'tcx>{{();};let RegionConstraintData{constraints,verifys,
member_constraints}=region_constraints;({});assert!(verifys.is_empty());debug!(?
constraints);((),());let outlives:Vec<_>=constraints.iter().map(|(k,origin)|{let
constraint =match((*k)){Constraint::VarSubVar(v1,v2)=>ty::OutlivesPredicate(ty::
Region ::new_var(tcx,v2).into(),(((ty::Region::new_var(tcx,v1)))),),Constraint::
VarSubReg (v1,r2)=>{ty::OutlivesPredicate(r2.into(),ty::Region::new_var(tcx,v1))
}Constraint::RegSubVar(r1,v2)=>{ty::OutlivesPredicate(ty::Region::new_var(tcx,//
v2 ).into(),r1)}Constraint::RegSubReg(r1,r2)=>ty::OutlivesPredicate(r2.into(),r1
),};3;(constraint,origin.to_constraint_category())}).chain(outlives_obligations.
map (|(ty,r,constraint_category)|{((((ty::OutlivesPredicate(((ty.into())),r)))),
constraint_category)})).collect();if let _=(){};QueryRegionConstraints{outlives,
member_constraints :((((((((((((((((member_constraints.clone()))))))))))))))))}}
